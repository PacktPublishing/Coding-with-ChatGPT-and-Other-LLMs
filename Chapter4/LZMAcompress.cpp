// This is badly-written code to compress time-series data with LZMA2 method, 
// generated by Claude 3 from Anthropic.
// Date: 8th March 2024.
// These comments by Vincent Hall.


#include <lzma.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

struct LZMA2CompressedData {
    std::vector<uint8_t> compressed_data;
    lzma_stream strm = LZMA_STREAM_INIT;
};

LZMA2CompressedData CompressTabularDataWithLZMA2(const std::vector<std::vector<std::string>>& tabular_data) {
    LZMA2CompressedData compressed_data;
    lzma_ret ret = lzma_stream_encoder(&compressed_data.strm, UINT64_MAX, LZMA_PRESET_DEFAULT);

    if (ret != LZMA_OK) {
        std::cerr << "Error initializing LZMA2 encoder: " << ret << std::endl;
        return compressed_data;
    }

    compressed_data.strm.next_in = NULL;
    compressed_data.strm.avail_in = 0;

    uint8_t out_buffer[BUFSIZ];
    compressed_data.strm.next_out = out_buffer;
    compressed_data.strm.avail_out = sizeof(out_buffer);

    bool continue_encoding = true;
    while (continue_encoding) {
        ret = lzma_code(&compressed_data.strm, LZMA_RUN);
        if (ret == LZMA_STREAM_END) {
            continue_encoding = false;
        } else if (ret != LZMA_OK) {
            std::cerr << "Error encoding with LZMA2: " << ret << std::endl;
            lzma_end(&compressed_data.strm);
            compressed_data.compressed_data.clear();
            return compressed_data;
        }

        size_t compressed_size = sizeof(out_buffer) - compressed_data.strm.avail_out;
        compressed_data.compressed_data.insert(compressed_data.compressed_data.end(), out_buffer, out_buffer + compressed_size);
        compressed_data.strm.next_out = out_buffer;
        compressed_data.strm.avail_out = sizeof(out_buffer);
    }

    for (const auto& row : tabular_data) {
        std::string row_data;
        for (const auto& cell : row) {
            row_data += cell + "\t";
        }
        row_data.pop_back();
        compressed_data.strm.next_in = reinterpret_cast<const uint8_t*>(row_data.data());
        compressed_data.strm.avail_in = row_data.size();
        continue_encoding = true;
        while (continue_encoding) {
            ret = lzma_code(&compressed_data.strm, LZMA_RUN);
            if (ret == LZMA_STREAM_END) {
                continue_encoding = false;
            } else if (ret != LZMA_OK) {
                std::cerr << "Error encoding with LZMA2: " << ret << std::endl;
                lzma_end(&compressed_data.strm);
                compressed_data.compressed_data.clear();
                return compressed_data;
            }

            size_t compressed_size = sizeof(out_buffer) - compressed_data.strm.avail_out;
            compressed_data.compressed_data.insert(compressed_data.compressed_data.end(), out_buffer, out_buffer + compressed_size);
            compressed_data.strm.next_out = out_buffer;
            compressed_data.strm.avail_out = sizeof(out_buffer);
        }
    }

    lzma_end(&compressed_data.strm);
    return compressed_data;
}

int main() {
    std::vector<std::vector<std::string>> tabular_data = {
        {"Name", "Age", "City"},
        {"Alice", "25", "New York"},
        {"Bob", "30", "Los Angeles"},
        {"Charlie", "35", "Chicago"}
    };

    LZMA2CompressedData compressed_data = CompressTabularDataWithLZMA2(tabular_data);

    std::ofstream output_file("compressed_data.lzma2", std::ios::binary);
    output_file.write(reinterpret_cast<const char*>(compressed_data.compressed_data.data()), compressed_data.compressed_data.size());
    output_file.close();

    return 0;
}
